buildscript {
    dependencies {
        classpath "com.squareup.okhttp3:okhttp:${project['okhttp3.version']}"
        classpath "com.google.guava:guava:${project['guava.version']}"
        classpath "com.google.googlejavaformat:google-java-format:${project['google-java-format.version']}"
    }
}

plugins {
    id 'groovy'
    id 'java'
    id 'com.heroku.sdk.heroku-gradle' version "${herokuPluginVersion}"
    id 'io.spring.dependency-management' version "${springDependencyManagementPluginVersion}"
    id 'org.springframework.boot' version "${springBootPluginVersion}"
    id 'com.gorylenko.gradle-git-properties' version "${gitPropertiesPluginVersion}"
    id 'checkstyle'
    id 'pmd'
    id 'com.github.spotbugs' version "${spotBugsPluginVersion}"
    id 'jacoco'
}

import com.google.common.io.CharSink
import com.google.common.io.Files as GoogleFiles
import com.google.googlejavaformat.java.Formatter
import com.google.googlejavaformat.java.JavaFormatterOptions

import groovy.io.FileType

import groovy.json.JsonOutput
import okhttp3.MediaType
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.RequestBody
import okhttp3.Response

import java.nio.charset.Charset
import java.nio.file.Files

sourceCompatibility=project['jdk.version']

configurations {
    agent
    intTestImplementation.extendsFrom testImplementation
    intTestRuntime.extendsFrom intTestImplementation
}

sourceSets {
    // Note that just declaring this sourceset creates two configurations.
    intTest {
        groovy {
            srcDir file('src/intTest/groovy')
            compileClasspath += main.output
            runtimeClasspath += main.output
        }
    }
}

// Static Analysis Plugin Configuration

checkstyle {
    configFile project.file('config/checkstyle/checkstyle.xml')
    toolVersion project['checkstyle.version']
}

jacoco {
    toolVersion = project['jacoco.version']
}

jacocoTestReport {
    reports {
        html.enabled true
        xml.enabled true
        csv.enabled false
    }

    afterEvaluate {
        classDirectories.setFrom(files(classDirectories.files.collect {
            fileTree(dir: it, excludes: ['com/jdpgrailsdev/oasis/timeline/config/**',
                                         'com/jdpgrailsdev/oasis/timeline/Application*'])
        }))
    }
}

jacocoTestCoverageVerification {
    violationRules {
        rule {
            element = 'CLASS'
            excludes = ['**/*Test*', '**/*Spec*', '**/*$$*', '**closure*',
                        '**Application*', '**Configuration*', '**TweetContext*']
            limit {
                counter = 'BRANCH'
                minimum = 0.8
            }
            limit {
                counter = 'INSTRUCTION'
                minimum = 0.8
            }
        }
    }
}

pmd {
    consoleOutput true
    ignoreFailures false
    ruleSets = []
    ruleSetFiles = files('config/pmd/pmd.xml')
    toolVersion project['pmd.version']
}

spotbugs {
    ignoreFailures = false
    effort = 'max'
    reportLevel = 'low'
    showProgress = false
    toolVersion = project['spotbugs.version']
}

spotbugsMain {
    reports {
        xml.enabled = false
        html.enabled = true
    }
}

// Project Dependencies

repositories {
    mavenCentral()
}

dependencies {
    agent "com.newrelic.agent.java:newrelic-agent:${project['newrelic.version']}"

    spotbugs "com.github.spotbugs:spotbugs:${project['spotbugs.version']}"

    implementation "com.github.spotbugs:spotbugs-annotations:${project['spotbugs.version']}"
    implementation 'com.fasterxml.jackson.core:jackson-annotations'
    implementation 'com.fasterxml.jackson.core:jackson-core'
    implementation 'com.fasterxml.jackson.core:jackson-databind'
    implementation "com.google.guava:guava:${project['guava.version']}"
    implementation "com.newrelic.agent.java:newrelic-api:${project['newrelic.version']}"
    implementation "com.newrelic.telemetry:micrometer-registry-new-relic:${project['micrometer-registry-new-relic.version']}"
    implementation 'io.micrometer:micrometer-core'
    implementation 'org.springframework:spring-context'
    implementation 'org.springframework.boot:spring-boot'
    implementation 'org.springframework.boot:spring-boot-autoconfigure'
    implementation 'org.springframework.boot:spring-boot-starter-actuator'
    implementation 'org.springframework.boot:spring-boot-starter-security'
    implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'io.projectreactor:reactor-core'
    implementation "org.twitter4j:twitter4j-core:${project['twitter4j-core.version']}"
    implementation 'org.slf4j:slf4j-api'

    testImplementation ('org.springframework.boot:spring-boot-starter-test') {
        exclude group: 'org.junit.vintage', module: 'junit-vintage-engine'
    }
    testImplementation "org.mockito:mockito-core:${project['mockito-core.version']}"
    testImplementation "org.codehaus.groovy:groovy:${project['groovy.version']}"
    testImplementation ("org.codehaus.groovy:groovy-all:${project['groovy.version']}") {
        exclude group: 'org.testng', module: 'testng'
    }
    testImplementation "org.spockframework:spock-core:${project['spock.version']}"
    testImplementation "org.spockframework:spock-junit4:${project['spock.version']}"

    intTestImplementation "org.spockframework:spock-spring:${project['spock.version']}"
}

// Deployment Configuration

heroku {
    appName = project.name
    jdkVersion = project['jdk.version']
    includeBuildDir = false
    includes = ["autobot/build/libs/${project.name}-${project.version}.jar".toString(), 'autobot/build/libs/newrelic-agent.jar']
    processTypes(
            web: ['java', '-Dserver.port=$PORT', '-Duser.timezone=UTC', '-Dnewrelic.config.distributed_tracing.enabled=true',
                  '-Dnewrelic.config.span_events=true', '-Dnewrelic.environment=production', '-XX:-OmitStackTraceInFastThrow',
                  '-javaagent:autobot/build/libs/newrelic-agent.jar', '-jar', "autobot/build/libs/${project.name}-${project.version}.jar".toString()].join(' ')
    )
}

// Spring Boot Configuration

jar {
    // Disable the building of the "plain" archive to avoid duplicate archives in build/lib
    // This is necessary due to the inclusion of by the jar task by the New Relic Gradle plugins
    // and the bootJar task by Spring Boot plugin.  See
    // https://docs.spring.io/spring-boot/docs/current/gradle-plugin/reference/htmlsingle/#packaging-executable.and-plain-archives
    // for more details
    enabled = false
}

bootRun {
    // Enable commented out section for local staging debugging
    environment << [
            INSERT_API_KEY: '',
            METRICS_API_URI: 'http://localhost',
            NEW_RELIC_APP_NAME: 'oasis-timeline-autobot',
            SPRING_ACTUATOR_USERNAME: 'user',
            SPRING_ACTUATOR_PASSWORD: 'password',
            SPRING_PROFILES_ACTIVE: 'development',
            TWITTER_OAUTH_CONSUMER_KEY: '',
            TWITTER_OAUTH_CONSUMER_SECRET: '',
            TWITTER_OAUTH_ACCESS_TOKEN: '',
            TWITTER_OAUTH_ACCESS_TOKEN_SECRET: ''
    ]

    jvmArgs = [
            '-Duser.timezone=UTC'
    ]
}

springBoot {
    buildInfo()
    mainClass = project.mainClass
}


// Custom Tasks

task copyDataFile(type: Copy) {
    from "${project.rootProject.projectDir}/web/src/data"
    into 'src/main/resources/json'
    include '*.json'
    filter { line -> line
        .replaceAll('<i>', '\'')
        .replaceAll('</i>', '\'')
        .replaceAll('<[^>]*>', '') }
}

task downloadAgent {
    doLast {
        project.configurations.agent.resolvedConfiguration.firstLevelModuleDependencies.moduleArtifacts.each { artifact ->
            project.copy {
                from artifact.file
                into "${project.buildDir}/libs"
                rename 'newrelic-agent-.*\\.jar', 'newrelic-agent.jar'
            }
        }
    }
}

clean {
    doLast {
        delete 'src/main/resources/json'
    }
}

task intTest(type:Test) {
    description = "Run integration tests (located in src/intTest/...)."
    testClassesDirs = project.sourceSets.intTest.output.classesDirs
    classpath = project.sourceSets.intTest.runtimeClasspath
    reports.html.destination = file("$reports.html.destination/integration")
    reports.junitXml.destination = file("$reports.junitXml.destination/integration")
    doFirst {
        environment << [
                INSERT_API_KEY: '',
                METRICS_API_URI: 'http://localhost',
                NEW_RELIC_APP_NAME: 'oasis-timeline-autobot',
                SPRING_ACTUATOR_USERNAME: 'user',
                SPRING_ACTUATOR_PASSWORD: 'password',
                SPRING_PROFILES_ACTIVE: 'test',
                TWITTER_OAUTH_CONSUMER_KEY: '',
                TWITTER_OAUTH_CONSUMER_SECRET: '',
                TWITTER_OAUTH_ACCESS_TOKEN: '',
                TWITTER_OAUTH_ACCESS_TOKEN_SECRET: ''
        ]

        jvmArgs = ['-Duser.timezone=UTC'
// Uncomment to enable remote debugging from an IDE
//         '-Xdebug',
//         "-Xrunjdwp:server=y,transport=dt_socket,address=${(project.port as int) + 1},suspend=y",
        ]

    }
    useJUnitPlatform()
}

task markDeploy {
    doLast {
        if(project.hasProperty('newRelicRestApiKey') && project.hasProperty('newRelicApplicationId')) {
            // Create deployment marker payload
            def json = JsonOutput.toJson([deployment:[
                revision: 'git rev-parse HEAD'.execute().text.trim(),
                changelog: 'git log -1 --pretty=%B'.execute().text.trim(),
                description: "Deployment of ${project.name}",
                user: System.getProperty('user.name')]])

            // Send request
            OkHttpClient client = new OkHttpClient()
            RequestBody body = RequestBody.create(json, MediaType.get('application/json; charset=utf-8'))
            Request request = new Request.Builder()
                .url("https://api.newrelic.com/v2/applications/${project['newRelicApplicationId']}/deployments.json")
                .header('X-Api-Key', project['newRelicRestApiKey'])
                .post(body)
                .build()
            Response response = client.newCall(request).execute()
            project.logger.info("Deployment marker response: ${response.body().string()}")
        } else {
            project.logger.lifecycle('Skipping recording of deployment:  \'newRelicRestApiKey\' and \'newRelicApplicationId\' properties must both be set.')
        }
    }
}

task formatSource {
    doLast {
        Formatter formatter = new Formatter(new JavaFormatterOptions(
                JavaFormatterOptions.Style.valueOf(JavaFormatterOptions.Style.GOOGLE.name()),
                true))

        project.sourceSets.each { sourceSet ->
            sourceSet.getAllJava().getSrcDirs().each { javaSourceDir ->
                if (Files.exists(javaSourceDir.toPath())) {
                    javaSourceDir.eachFileRecurse(FileType.FILES) { file ->
                        if (file.toString().endsWith('.java')) {
                            String input = file.text
                            String output = formatter.formatSourceAndFixImports(file.text)
                            if (output != input) {
                                CharSink outputSink = GoogleFiles.asByteSink(file)
                                        .asCharSink(Charset.defaultCharset())
                                outputSink.write(output)
                            }
                        }
                    }
                }
            }
        }
    }
}

// Test Configuration

test {
    useJUnitPlatform()
    doFirst {
        jvmArgs = ['-Duser.timezone=UTC']
    }
    jacoco {
        enabled = true
        excludes = ['**/*Test*', '**/*Spec*', '**/*$$*', '**closure*',
                    '**Application*', '**Configuration*', '**TweetContext*']
    }
    finalizedBy project.tasks.jacocoTestReport
}

// Task Dependencies

project.tasks.processResources.dependsOn([project.tasks.copyDataFile])
assemble.dependsOn(project.tasks.downloadAgent)
project.tasks.publish.dependsOn([project.tasks.build, project.tasks.deployHeroku])
project.tasks.publish.finalizedBy(project.tasks.markDeploy)
project.tasks.checkstyleMain.dependsOn([project.tasks.formatSource])
project.tasks.copyDataFile.outputs.upToDateWhen { false }
project.tasks.jacocoTestReport.outputs.upToDateWhen { false }
test.finalizedBy(project.tasks.jacocoTestReport)

// Always execute the tests -- needed for Jenkins to be happy
test.outputs.upToDateWhen { false }

/*
 * Set the integration tests to run during the check task
 * immediately after the unit tests have run.
 */
check.dependsOn([intTest, formatSource, project.tasks.jacocoTestCoverageVerification])
intTest.mustRunAfter test

// Disable SpotBugs analysis for test code
project.tasks.spotbugsTest.enabled = false
project.tasks.spotbugsIntTest.enabled = false