buildscript {
    dependencies {
        classpath "com.squareup.okhttp3:okhttp:${project['okhttp3.version']}"
    }
}

plugins {
    id 'groovy'
    id 'jacoco'
    id 'java'
    id 'com.github.spotbugs' version "${spotBugsPluginVersion}"
    id 'com.heroku.sdk.heroku-gradle' version "${herokuPluginVersion}"
    id 'io.spring.dependency-management' version "${springDependencyManagementPluginVersion}"
    id 'org.springframework.boot' version "${springBootPluginVersion}"
    id 'com.gorylenko.gradle-git-properties' version "${gitPropertiesPluginVersion}"
}

import groovy.json.JsonOutput
import okhttp3.MediaType
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.RequestBody
import okhttp3.Response

sourceCompatibility=11

configurations {
    agent
    intTestImplementation.extendsFrom testImplementation
    intTestRuntime.extendsFrom intTestImplementation
}

repositories {
    mavenCentral()
}

dependencies {
    agent "com.newrelic.agent.java:newrelic-agent:${project['newrelic.version']}"

    implementation 'com.fasterxml.jackson.core:jackson-annotations'
    implementation 'com.fasterxml.jackson.core:jackson-core'
    implementation 'com.fasterxml.jackson.core:jackson-databind'
    implementation "com.google.guava:guava:${project['guava.version']}"
    implementation "com.newrelic.agent.java:newrelic-api:${project['newrelic.version']}"
    implementation "com.newrelic.telemetry:micrometer-registry-new-relic:${project['micrometer-registry-new-relic.version']}"
    implementation 'io.micrometer:micrometer-core'
    implementation 'org.springframework:spring-context'
    implementation 'org.springframework.boot:spring-boot'
    implementation 'org.springframework.boot:spring-boot-autoconfigure'
    implementation 'org.springframework.boot:spring-boot-starter-actuator'
    implementation 'org.springframework.boot:spring-boot-starter-security'
    implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'io.projectreactor:reactor-core'
    implementation "org.twitter4j:twitter4j-core:${project['twitter4j-core.version']}"
    implementation 'org.slf4j:slf4j-api'

    testImplementation ('org.springframework.boot:spring-boot-starter-test') {
        exclude group: 'org.junit.vintage', module: 'junit-vintage-engine'
    }
    testImplementation "org.mockito:mockito-core:${project['mockito-core.version']}"
    testImplementation "org.codehaus.groovy:groovy:${project['groovy.version']}"
    testImplementation ("org.codehaus.groovy:groovy-all:${project['groovy.version']}") {
        exclude group: 'org.testng', module: 'testng'
    }
    testImplementation "org.spockframework:spock-core:${project['spock.version']}"
    testImplementation "org.spockframework:spock-junit4:${project['spock.version']}"

    intTestImplementation "org.spockframework:spock-spring:${project['spock.version']}"
}

task copyDataFile(type: Copy) {
    from "${project.rootProject.projectDir}/web/src/data"
    into 'src/main/resources/json'
    include '*.json'
    filter { line -> line
        .replaceAll('<i>', '\'')
        .replaceAll('</i>', '\'')
        .replaceAll('<[^>]*>', '') }
}

task downloadAgent {
    doLast {
        project.configurations.agent.resolvedConfiguration.firstLevelModuleDependencies.moduleArtifacts.each { artifact ->
            project.copy {
                from artifact.file
                into "${project.buildDir}/libs"
                rename 'newrelic-agent-.*\\.jar', 'newrelic-agent.jar'
            }
        }
    }
}

bootJar {
    archiveName = "${project.name}.jar"
    mainClassName = 'com.jdpgrailsdev.oasis.timeline.Application'
}

bootRun {
    // Enable commented out section for local staging debugging
    environment << [
        INSERT_API_KEY: '',
        METRICS_API_URI: 'http://localhost',
        NEW_RELIC_APP_NAME: 'oasis-timeline-autobot',
        SPRING_ACTUATOR_USERNAME: 'user',
        SPRING_ACTUATOR_PASSWORD: 'password',
        SPRING_PROFILES_ACTIVE: 'development',
        TWITTER_OAUTH_CONSUMER_KEY: '',
        TWITTER_OAUTH_CONSUMER_SECRET: '',
        TWITTER_OAUTH_ACCESS_TOKEN: '',
        TWITTER_OAUTH_ACCESS_TOKEN_SECRET: ''
    ]

    jvmArgs = [
        '-Duser.timezone=UTC'
    ]
}

clean {
    doLast {
        delete 'src/main/resources/json'
    }
}

heroku {
    appName = project.name
    jdkVersion = 11
    includeBuildDir = false
    includes = ["autobot/build/libs/${project.name}.jar".toString(), 'autobot/build/libs/newrelic-agent.jar']
    processTypes(
        web: ['java', '-Dserver.port=$PORT', '-Duser.timezone=UTC', '-Dnewrelic.config.distributed_tracing.enabled=true',
            '-Dnewrelic.config.span_events=true', '-Dnewrelic.environment=production', '-XX:-OmitStackTraceInFastThrow',
            '-javaagent:autobot/build/libs/newrelic-agent.jar', '-jar', "autobot/build/libs/${project.name}.jar".toString()].join(' ')
    )
}

jacoco {
    toolVersion = project['jacoco.version']
}

jacocoTestReport {
    reports {
        html.enabled = true
        xml.enabled = true
        csv.enabled = false
    }

    afterEvaluate {
      classDirectories.setFrom(files(classDirectories.files.collect {
        fileTree(dir: it, excludes: ['com/jdpgrailsdev/oasis/timeline/config/**', 'com/jdpgrailsdev/oasis/timeline/Application*'])
      }))
    }
}

sourceSets {
    // Note that just declaring this sourceset creates two configurations.
    intTest {
        groovy {
            srcDir file('src/intTest/groovy')
            compileClasspath += main.output
            runtimeClasspath += main.output
        }
    }
}

spotbugs {
    ignoreFailures = true
    toolVersion = project['spotbugs.version']
}

spotbugsMain {
    reports {
        xml.enabled = false
        html.enabled = true
    }
}

springBoot {
    buildInfo()
}

test {
    useJUnitPlatform()
    doFirst {
        jvmArgs = ['-Duser.timezone=UTC']
    }
}

task intTest(type:Test) {
    description = 'Run integration tests (located in src/intTest/...).'
    testClassesDirs = project.sourceSets.intTest.output.classesDirs
    classpath = project.sourceSets.intTest.runtimeClasspath
    reports.html.destination = file("$reports.html.destination/integration")
    reports.junitXml.destination = file("$reports.junitXml.destination/integration")
    doFirst {
        environment << [
                INSERT_API_KEY: '',
                METRICS_API_URI: 'http://localhost',
                NEW_RELIC_APP_NAME: 'oasis-timeline-autobot',
                SPRING_ACTUATOR_USERNAME: 'user',
                SPRING_ACTUATOR_PASSWORD: 'password',
                SPRING_PROFILES_ACTIVE: 'test',
                TWITTER_OAUTH_CONSUMER_KEY: '',
                TWITTER_OAUTH_CONSUMER_SECRET: '',
                TWITTER_OAUTH_ACCESS_TOKEN: '',
                TWITTER_OAUTH_ACCESS_TOKEN_SECRET: ''
        ]

        jvmArgs = ['-Duser.timezone=UTC'
// Uncomment to enable remote debugging from an IDE
//         '-Xdebug',
//         "-Xrunjdwp:server=y,transport=dt_socket,address=${(project.port as int) + 1},suspend=y",
        ]

    }
    useJUnitPlatform()
}

task markDeploy {
    doLast {
        if(project.hasProperty('newRelicRestApiKey') && project.hasProperty('newRelicApplicationId')) {
            // Create deployment marker payload
            def json = JsonOutput.toJson([deployment:[
                revision: 'git rev-parse HEAD'.execute().text.trim(),
                changelog: 'git log -1 --pretty=%B'.execute().text.trim(),
                description: "Deployment of ${project.name}",
                user: System.getProperty('user.name')]])

            // Send request
            OkHttpClient client = new OkHttpClient()
            RequestBody body = RequestBody.create(json, MediaType.get('application/json; charset=utf-8'))
            Request request = new Request.Builder()
                .url("https://api.newrelic.com/v2/applications/${project['newRelicApplicationId']}/deployments.json")
                .header('X-Api-Key', project['newRelicRestApiKey'])
                .post(body)
                .build()
            Response response = client.newCall(request).execute()
            project.logger.info("Deployment marker response: ${response.body().string()}")
        } else {
            project.logger.lifecycle('Skipping recording of deployment:  \'newRelicRestApiKey\' and \'newRelicApplicationId\' properties must both be set.')
        }
    }
}

// Task dependencies
project.tasks.processResources.dependsOn([project.tasks.copyDataFile])
assemble.dependsOn(project.tasks.downloadAgent)
project.tasks.publish.dependsOn([project.tasks.build, project.tasks.deployHeroku])
project.tasks.publish.finalizedBy(project.tasks.markDeploy)
project.tasks.copyDataFile.outputs.upToDateWhen { false }
project.tasks.jacocoTestReport.outputs.upToDateWhen { false }
test.finalizedBy(project.tasks.jacocoTestReport)

// Always execute the tests -- needed for Jenkins to be happy
test.outputs.upToDateWhen { false }

/*
 * Set the integration tests to run during the check task
 * immediately after the unit tests have run.
 */
check.dependsOn intTest
intTest.mustRunAfter test

// Disable SpotBugs analysis for test code
project.tasks.spotbugsTest.enabled = false
project.tasks.spotbugsIntTest.enabled = false